===== SEND FORGE — RULE 13 EXPORT =====
Batch: UI Stability Patch + Add Contact Fix
RepoRoot: C:\sendforge\comms-app
Timestamp: 2026-02-28 07:18:37


===== MIGRATIONS DIRECTORY LISTING =====
===== MIGRATIONS DIR NOT FOUND: services/backend/migrations =====




===== FILE: apps/mobile/lib/ui/screens/create_blast_screen.dart =====


// comms-app/apps/mobile/lib/ui/screens/create_blast_screen.dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../core/app_state.dart';
import '../../models/blast.dart';
import '../../services/blasts_api.dart';
import '../../services/api_client.dart';
import '../colors.dart';
import '../icons.dart';
import '../components/sf_card.dart';
import '../components/sf_primary_button.dart';
import '../../models/group.dart';
import 'threads_screen.dart';

class CreateBlastScreen extends StatefulWidget {
  final AppState appState;
  const CreateBlastScreen({super.key, required this.appState});

  @override
  State<CreateBlastScreen> createState() => _CreateBlastScreenState();
}

class _CreateBlastScreenState extends State<CreateBlastScreen> {
  final _formKey = GlobalKey<FormState>();
  final BlastDraft draft = BlastDraft();

  final _nameCtrl = TextEditingController(text: 'Smoke Test');
  final _subjectCtrl = TextEditingController();
  final _bodyCtrl = TextEditingController();

  final _nameFocus = FocusNode();
  final _subjectFocus = FocusNode();
  final _bodyFocus = FocusNode();

  final FocusNode _kbdFocus = FocusNode();

  /// Channels
  final Set<Channel> _channels = {Channel.sms};

  /// Groups (IDs)
  final Set<String> _selectedGroupIds = {};

  bool busy = false;
  String? status;

  bool get hasEmail => _channels.contains(Channel.email);
  bool get hasSms => _channels.contains(Channel.sms);

  @override
  void dispose() {
    _nameCtrl.dispose();
    _subjectCtrl.dispose();
    _bodyCtrl.dispose();
    _nameFocus.dispose();
    _subjectFocus.dispose();
    _bodyFocus.dispose();
    _kbdFocus.dispose();
    super.dispose();
  }

  void _openGroupPicker() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (_) {
        return StatefulBuilder(
          builder: (context, modalSetState) {
            return _GroupPicker(
              groups: widget.appState.groups,
              selected: _selectedGroupIds,
              onToggle: (id) {
                modalSetState(() {});
                setState(() {
                  _selectedGroupIds.contains(id)
                      ? _selectedGroupIds.remove(id)
                      : _selectedGroupIds.add(id);
                });
              },
            );
          },
        );
      },
    );
  }

  Future<bool> _confirmInternational(String estUsd, bool chargeNow) async {
    return await showDialog<bool>(
          context: context,
          builder: (_) => AlertDialog(
            title: const Text("International SMS charges"),
            content: Text(
              "This blast includes international recipients.\n\n"
              "Estimated international cost: \$$estUsd\n\n"
              "Charges are based on destination and billed to your saved payment method.",
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: const Text("Cancel"),
              ),
              ElevatedButton(
                onPressed: () => Navigator.pop(context, true),
                child: Text(chargeNow ? "Confirm & Charge Now" : "Confirm & Send"),
              ),
            ],
          ),
        ) ??
        false;
  }

  Future<void> _send() async {
    setState(() => status = null);

    if (!_formKey.currentState!.validate()) return;

    if (_channels.isEmpty) {
      setState(() => status = 'Select at least one channel.');
      return;
    }

    if (_selectedGroupIds.isEmpty) {
      setState(() => status = 'Select at least one group.');
      return;
    }

    draft.channels = _channels.toSet();
    draft.name = _nameCtrl.text.trim();
    draft.subject = _subjectCtrl.text.trim();
    draft.body = _bodyCtrl.text.trim();
    draft.groupIds = _selectedGroupIds.toList();

    setState(() => busy = true);

    try {
      final apiClient = ApiClient(baseUrl: widget.appState.baseUrl);
      final blastsApi = BlastsApi(apiClient);

      final channels = _channels.map((c) => c == Channel.sms ? "sms" : "email").toList();

      // 1) Quote
      final quote = await blastsApi.quote(
        groupIds: _selectedGroupIds.toList(),
        channels: channels,
        body: draft.body,
      );

      if (quote['blocked'] == true) {
        setState(() => status = 'Blocked: ${quote['blockedReason'] ?? 'not allowed'}');
        return;
      }

      final intlCount = (quote['intlCount'] ?? 0) as int;
      final requiresConfirm = quote['requiresConfirm'] == true;

      if (requiresConfirm && intlCount > 0) {
        final est = quote['estimatedIntlUsd']?.toString() ?? '0.00';
        final chargeNow = quote['requiresImmediateCharge'] == true;

        final ok = await _confirmInternational(est, chargeNow);
        if (!ok) return;
      }

      // 2) Send
      final resp = await blastsApi.send(
        groupIds: _selectedGroupIds.toList(),
        channels: channels,
        body: draft.body,
        quote: quote,
      );

      final blastId = (resp['blastId'] ?? DateTime.now().millisecondsSinceEpoch.toString()).toString();
      setState(() => status = 'Queued âœ… ($blastId)');

      widget.appState.addQueuedBlastAsThread(
        blastId: blastId,
        body: draft.body,
      );

      if (!mounted) return;
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => ThreadsScreen(appState: widget.appState),
        ),
      );
    } catch (e) {
      setState(() => status = 'Error: $e');
    } finally {
      setState(() => busy = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final needsSubject = hasEmail;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Blast'),
        backgroundColor: SFColors.primaryBlue,
        foregroundColor: Colors.white,
      ),
      body: RawKeyboardListener(
        focusNode: _kbdFocus,
        autofocus: true,
        onKey: (evt) async {
          // Ctrl+Enter sends (desktop/web)
          final isDown = evt is RawKeyDownEvent;
          if (!isDown) return;

          final isEnter = evt.logicalKey == LogicalKeyboardKey.enter ||
              evt.logicalKey == LogicalKeyboardKey.numpadEnter;

          if (!isEnter) return;

          final isCtrl = evt.isControlPressed || evt.isMetaPressed;

          // If in body, plain Enter should be newline (TextFormField handles it).
          // Only Ctrl+Enter triggers send.
          if (isCtrl) {
            await _send();
          }
        },
        child: SafeArea(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Form(
              key: _formKey,
              child: Column(
                children: [
                  SFCard(
                    title: 'Channels',
                    subtitle: 'Select one or both (SMS + Email)',
                    child: Wrap(
                      spacing: 12,
                      children: Channel.values.map((c) {
                        final selected = _channels.contains(c);
                        final label = c == Channel.sms ? 'SMS' : 'Email';

                        return InkWell(
                          borderRadius: BorderRadius.circular(12),
                          onTap: () {
                            setState(() {
                              selected ? _channels.remove(c) : _channels.add(c);
                            });
                          },
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 12),
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(12),
                              color: selected ? SFColors.primaryBlue : Colors.white,
                              border: Border.all(
                                color: selected ? SFColors.primaryBlue : SFColors.cardBorder,
                              ),
                            ),
                            child: Text(
                              label,
                              style: TextStyle(
                                fontWeight: FontWeight.w700,
                                color: selected ? Colors.white : SFColors.textPrimary,
                              ),
                            ),
                          ),
                        );
                      }).toList(),
                    ),
                  ),

                  const SizedBox(height: 14),

                  SFCard(
                    title: 'Reply mode',
                    subtitle: 'Private = sender only â€¢ Group = shared thread',
                    child: _ReplyModeSlider(
                      value: draft.replyMode,
                      onChanged: (v) => setState(() => draft.replyMode = v),
                    ),
                  ),

                  const SizedBox(height: 14),

                  SFCard(
                    title: 'Message',
                    child: Column(
                      children: [
                        TextFormField(
                          controller: _nameCtrl,
                          focusNode: _nameFocus,
                          textInputAction: TextInputAction.next,
                          onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_subjectFocus),
                          decoration: const InputDecoration(
                            labelText: 'Name',
                            prefixIcon: Icon(Icons.edit_outlined),
                          ),
                        ),
                        const SizedBox(height: 12),
                        TextFormField(
                          controller: _subjectCtrl,
                          focusNode: _subjectFocus,
                          textInputAction: TextInputAction.next,
                          onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_bodyFocus),
                          decoration: InputDecoration(
                            labelText: needsSubject ? 'Subject (required for email)' : 'Subject (email only)',
                            prefixIcon: const Icon(SFIcons.email),
                          ),
                          validator: (v) {
                            if (needsSubject && (v == null || v.trim().isEmpty)) {
                              return 'Subject required when Email is selected.';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 12),
                        TextFormField(
                          controller: _bodyCtrl,
                          focusNode: _bodyFocus,
                          textInputAction: TextInputAction.newline,
                          keyboardType: TextInputType.multiline,
                          minLines: 4,
                          maxLines: 10,
                          decoration: InputDecoration(
                            labelText: 'Body',
                            helperText: kIsWeb ? 'Tip: Ctrl+Enter to send' : null,
                            prefixIcon: Icon(hasEmail && !hasSms ? SFIcons.email : SFIcons.sms),
                          ),
                          validator: (v) => (v == null || v.trim().isEmpty) ? 'Body is required.' : null,
                        ),
                      ],
                    ),
                  ),

                  const SizedBox(height: 14),

                  SFCard(
                    title: 'Groups',
                    subtitle: 'Select one or more groups',
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        OutlinedButton.icon(
                          icon: const Icon(Icons.group),
                          label: const Text('Select Groups'),
                          onPressed: _openGroupPicker,
                        ),
                        if (_selectedGroupIds.isNotEmpty) ...[
                          const SizedBox(height: 8),
                          Text(
                            '${_selectedGroupIds.length} group(s) selected',
                            style: const TextStyle(fontSize: 12),
                          ),
                        ],
                      ],
                    ),
                  ),

                  const SizedBox(height: 16),

                  SizedBox(
                    width: double.infinity,
                    child: SFPrimaryButton(
                      icon: SFIcons.queue,
                      label: busy ? 'Queuingâ€¦' : 'Queue Blast',
                      busy: busy,
                      onPressed: busy ? null : _send,
                    ),
                  ),

                  if (status != null) ...[
                    const SizedBox(height: 12),
                    _StatusBanner(text: status!),
                  ],
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _GroupPicker extends StatelessWidget {
  final List<Group> groups;
  final Set<String> selected;
  final ValueChanged<String> onToggle;

  const _GroupPicker({
    required this.groups,
    required this.selected,
    required this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          const Text(
            'Select Groups',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 12),
          ...groups.map((g) {
            final isSelected = selected.contains(g.id);
            return ListTile(
              leading: Icon(
                Icons.group,
                color: isSelected ? SFColors.primaryBlue : Colors.grey,
              ),
              title: Text(g.name),
              subtitle: g.type == "meta" ? const Text("Meta group (dynamic)") : null,
              trailing: isSelected ? const Icon(Icons.check_circle) : null,
              onTap: () => onToggle(g.id),
            );
          }),
        ],
      ),
    );
  }
}

class _ReplyModeSlider extends StatelessWidget {
  final ReplyMode value;
  final ValueChanged<ReplyMode> onChanged;

  const _ReplyModeSlider({required this.value, required this.onChanged});

  @override
  Widget build(BuildContext context) {
    final isPrivate = value == ReplyMode.private;
    return Row(
      children: [
        Expanded(
          child: _chip(
            selected: isPrivate,
            icon: SFIcons.replyPrivate,
            label: 'Private',
            onTap: () => onChanged(ReplyMode.private),
          ),
        ),
        const SizedBox(width: 10),
        Expanded(
          child: _chip(
            selected: !isPrivate,
            icon: SFIcons.replyGroup,
            label: 'Group',
            onTap: () => onChanged(ReplyMode.group),
          ),
        ),
      ],
    );
  }

  Widget _chip({
    required bool selected,
    required IconData icon,
    required String label,
    required VoidCallback onTap,
  }) {
    return InkWell(
      borderRadius: BorderRadius.circular(12),
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          color: selected ? SFColors.primaryBlue : Colors.white,
          border: Border.all(
            color: selected ? SFColors.primaryBlue : Colors.black12,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, color: selected ? Colors.white : SFColors.primaryBlue),
            const SizedBox(width: 8),
            Text(
              label,
              style: TextStyle(
                fontWeight: FontWeight.w900,
                color: selected ? Colors.white : SFColors.textPrimary,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _StatusBanner extends StatelessWidget {
  final String text;
  const _StatusBanner({required this.text});

  @override
  Widget build(BuildContext context) {
    final isError = text.toLowerCase().contains('error') ||
        text.toLowerCase().contains('blocked') ||
        text.toLowerCase().contains('required');

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: isError ? Colors.redAccent.withOpacity(0.10) : Colors.green.withOpacity(0.10),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: isError ? Colors.redAccent : Colors.green),
      ),
      child: Row(
        children: [
          Icon(
            isError ? SFIcons.warning : Icons.check_circle_outline,
            color: isError ? Colors.redAccent : Colors.green,
          ),
          const SizedBox(width: 10),
          Expanded(child: Text(text)),
        ],
      ),
    );
  }
}


===== FILE: apps/mobile/lib/ui/screens/group_detail_screen.dart =====


// comms-app/apps/mobile/lib/ui/screens/group_detail_screen.dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../core/app_state.dart';
import '../../models/group.dart';
import '../../models/contact.dart';
import '../../services/groups_api.dart';
import '../components/compact_contact_tile.dart';
import '../colors.dart';
import '../groups/group_avatar_atlas.dart';

class GroupDetailScreen extends StatefulWidget {
  final AppState appState;
  final Group group;

  const GroupDetailScreen({
    super.key,
    required this.appState,
    required this.group,
  });

  @override
  State<GroupDetailScreen> createState() => _GroupDetailScreenState();
}

class _GroupDetailScreenState extends State<GroupDetailScreen> {
  // SNAPSHOT selection state
  late Set<String> _selectedMemberIds;

  // META linking state
  Set<String> _selectedChildGroupIds = {};
  bool _metaLoaded = false;

  final TextEditingController _search = TextEditingController();
  bool _saving = false;

  // Desktop shift select
  int? _lastTappedIndex;
  bool _shiftDown = false;
  final FocusNode _keyboardFocus = FocusNode();

  // Mobile long-hold + slide select
  bool _mobileDragMode = false;
  int? _mobileDragAnchorIndex;
  int? _mobileDragLastIndex;
  double _scrollOffset = 0;

  static const double _rowHeight = 56.0;

  @override
  void initState() {
    super.initState();
    _selectedMemberIds = widget.group.members.map((m) => m.id).toSet();

    if (_isMeta) {
      _loadMetaLinks();
    } else {
      _metaLoaded = true;
    }
  }

  bool get _isMeta => (widget.group.type == "meta");

  @override
  void dispose() {
    _search.dispose();
    _keyboardFocus.dispose();
    super.dispose();
  }

  Future<void> _loadMetaLinks() async {
    try {
      final api = GroupsApi(widget.appState);
      final children = await api.getMetaLinks(widget.group.id);
      setState(() {
        _selectedChildGroupIds = children.map((g) => g.id).toSet();
        _metaLoaded = true;
      });
    } catch (_) {
      setState(() => _metaLoaded = true);
    }
  }

  Future<void> _save() async {
    setState(() => _saving = true);

    try {
      final api = GroupsApi(widget.appState);

      if (_isMeta) {
        // âœ… meta: persist linked groups
        await api.updateMetaLinks(widget.group.id, _selectedChildGroupIds.toList());
        await widget.appState.loadGroups();
        if (!mounted) return;
        Navigator.pop(context);
        return;
      }

      // âœ… snapshot: persist membership
      final updated = await api.updateMembers(
        widget.group.id,
        _selectedMemberIds.toList(),
      );

      widget.appState.upsertGroup(updated);

      if (!mounted) return;
      Navigator.pop(context);
    } catch (e) {
      if (!mounted) return;
      setState(() => _saving = false);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("Save failed: $e")),
      );
    }
  }

  // ---------------------------
  // SNAPSHOT selection helpers
  // ---------------------------
  void _toggleSingleContact(Contact c) {
    setState(() {
      if (_selectedMemberIds.contains(c.id)) {
        _selectedMemberIds.remove(c.id);
      } else {
        _selectedMemberIds.add(c.id);
      }
    });
  }

  void _toggleRangeContacts(List<Contact> contacts, int a, int b, bool select) {
    final start = a < b ? a : b;
    final end = a < b ? b : a;

    setState(() {
      for (int i = start; i <= end; i++) {
        final id = contacts[i].id;
        if (select) {
          _selectedMemberIds.add(id);
        } else {
          _selectedMemberIds.remove(id);
        }
      }
    });
  }

  // ---------------------------
  // META linking helpers
  // ---------------------------
  void _toggleChildGroup(String groupId) {
    setState(() {
      if (_selectedChildGroupIds.contains(groupId)) {
        _selectedChildGroupIds.remove(groupId);
      } else {
        _selectedChildGroupIds.add(groupId);
      }
    });
  }

  void _showMembersModalForGroup(Group g) {
    final members = g.members;
    final tooLarge = members.length > 20;
    final shown = members.take(20).toList();

    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(g.name),
        content: SizedBox(
          width: 360,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (tooLarge)
                const Padding(
                  padding: EdgeInsets.only(bottom: 10),
                  child: Text(
                    "Large group â€” check Manage Groups for full member list.",
                    style: TextStyle(fontSize: 12),
                  ),
                ),
              ...shown.map((c) => Padding(
                    padding: const EdgeInsets.symmetric(vertical: 3),
                    child: Text(
                      c.name,
                      style: const TextStyle(fontWeight: FontWeight.w600),
                    ),
                  )),
            ],
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text("Close")),
        ],
      ),
    );
  }

  void _showContactModal(Contact c) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(c.name),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if ((c.organization ?? "").trim().isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(bottom: 8),
                child: Text("Org: ${c.organization}"),
              ),
            if ((c.phone ?? "").trim().isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(bottom: 6),
                child: Text("SMS: ${c.phone}"),
              ),
            if ((c.email ?? "").trim().isNotEmpty)
              Text("Email: ${c.email}"),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text("Close")),
        ],
      ),
    );
  }

  // Mobile drag-select: compute row index by y coordinate + scroll offset
  int _indexFromLocalDy(double dy) {
    final absolute = dy + _scrollOffset;
    final i = (absolute / _rowHeight).floor();
    return i < 0 ? 0 : i;
  }

  @override
  Widget build(BuildContext context) {
    final header = AppBar(
      title: Text(widget.group.name),
      backgroundColor: SFColors.primaryBlue,
      foregroundColor: Colors.white,
      actions: [
        IconButton(
          tooltip: "Save",
          onPressed: _saving ? null : _save,
          icon: _saving
              ? const SizedBox(
                  width: 18,
                  height: 18,
                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
                )
              : const Icon(Icons.save),
        ),
      ],
    );

    // ---------------------------
    // META UI
    // ---------------------------
    if (_isMeta) {
      final allGroups = widget.appState.groups
          .where((g) => g.id != widget.group.id) // canâ€™t link to itself
          .toList();

      // âœ… allow metaâ†’meta and metaâ†’snapshot; backend safeguards loops (confirmed by you)
      return Scaffold(
        appBar: header,
        body: !_metaLoaded
            ? const Center(child: CircularProgressIndicator())
            : SafeArea(
                child: Padding(
                  padding: const EdgeInsets.all(12),
                  child: Column(
                    children: [
                      // Header row: avatar opens compact member list for this meta group (resolved members)
                      Row(
                        children: [
                          GestureDetector(
                            onTap: () => _showMembersModalForGroup(widget.group),
                            child: (widget.group.avatarKey != null && widget.group.avatarKey!.isNotEmpty)
                                ? GroupAvatarAtlas(avatarKey: widget.group.avatarKey!, size: 48)
                                : Container(
                                    width: 48,
                                    height: 48,
                                    decoration: BoxDecoration(
                                      color: Colors.black.withOpacity(0.06),
                                      borderRadius: BorderRadius.circular(14),
                                    ),
                                    child: const Icon(Icons.group_outlined),
                                  ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  widget.group.name,
                                  style: const TextStyle(fontWeight: FontWeight.w900, fontSize: 16),
                                ),
                                const SizedBox(height: 2),
                                Text(
                                  "${widget.group.memberCount} members",
                                  style: TextStyle(
                                    fontSize: 12,
                                    color: Colors.black.withOpacity(0.6),
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      Align(
                        alignment: Alignment.centerLeft,
                        child: Text(
                          "Linked Groups",
                          style: TextStyle(
                            fontWeight: FontWeight.w800,
                            color: SFColors.textPrimary.withOpacity(0.85),
                          ),
                        ),
                      ),
                      const SizedBox(height: 8),
                      Expanded(
                        child: ListView.builder(
                          itemCount: allGroups.length,
                          itemBuilder: (context, i) {
                            final g = allGroups[i];
                            final checked = _selectedChildGroupIds.contains(g.id);

                            return InkWell(
                              onTap: () => _toggleChildGroup(g.id),
                              child: Container(
                                height: 56,
                                padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                                child: Row(
                                  children: [
                                    GestureDetector(
                                      onTap: () => _showMembersModalForGroup(g),
                                      child: (g.avatarKey != null && g.avatarKey!.isNotEmpty)
                                          ? GroupAvatarAtlas(avatarKey: g.avatarKey!, size: 40)
                                          : Container(
                                              width: 40,
                                              height: 40,
                                              decoration: BoxDecoration(
                                                color: Colors.black.withOpacity(0.06),
                                                borderRadius: BorderRadius.circular(12),
                                              ),
                                              child: const Icon(Icons.groups),
                                            ),
                                    ),
                                    const SizedBox(width: 10),
                                    Expanded(
                                      child: Column(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        mainAxisAlignment: MainAxisAlignment.center,
                                        children: [
                                          Text(
                                            g.name,
                                            style: const TextStyle(fontWeight: FontWeight.w800),
                                            overflow: TextOverflow.ellipsis,
                                          ),
                                          Text(
                                            "${g.memberCount} members",
                                            style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.black.withOpacity(0.55),
                                              fontWeight: FontWeight.w600,
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                    Checkbox(
                                      value: checked,
                                      onChanged: (_) => _toggleChildGroup(g.id),
                                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                      visualDensity: const VisualDensity(horizontal: -3, vertical: -3),
                                    ),
                                  ],
                                ),
                              ),
                            );
                          },
                        ),
                      ),
                    ],
                  ),
                ),
              ),
      );
    }

    // ---------------------------
    // SNAPSHOT UI
    // ---------------------------
    final allContacts = widget.appState.contacts;
    final query = _search.text.toLowerCase();

    final contacts = allContacts
        .where((c) =>
            c.name.toLowerCase().contains(query) ||
            (c.organization ?? '').toLowerCase().contains(query))
        .toList()
      ..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));

    return Scaffold(
      appBar: header,
      body: RawKeyboardListener(
        focusNode: _keyboardFocus,
        autofocus: true,
        onKey: (evt) {
          final isShift = evt.logicalKey == LogicalKeyboardKey.shiftLeft ||
              evt.logicalKey == LogicalKeyboardKey.shiftRight;
          if (isShift) {
            setState(() {
              _shiftDown = evt is RawKeyDownEvent;
            });
          }
        },
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(12, 12, 12, 8),
              child: TextField(
                controller: _search,
                decoration: InputDecoration(
                  hintText: "Search name or organization",
                  isDense: true,
                  filled: true,
                  fillColor: Colors.white,
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                ),
                onChanged: (_) => setState(() {}),
              ),
            ),

            if (_mobileDragMode)
              Padding(
                padding: const EdgeInsets.fromLTRB(12, 0, 12, 8),
                child: Row(
                  children: [
                    const Icon(Icons.swipe, size: 18),
                    const SizedBox(width: 8),
                    const Expanded(
                      child: Text(
                        "Range select: hold + slide. Release to finish.",
                        style: TextStyle(fontSize: 12),
                      ),
                    ),
                    TextButton(
                      onPressed: () => setState(() {
                        _mobileDragMode = false;
                        _mobileDragAnchorIndex = null;
                        _mobileDragLastIndex = null;
                      }),
                      child: const Text("Cancel"),
                    ),
                  ],
                ),
              ),

            Expanded(
              child: NotificationListener<ScrollNotification>(
                onNotification: (n) {
                  if (n.metrics.axis == Axis.vertical) {
                    _scrollOffset = n.metrics.pixels;
                  }
                  return false;
                },
                child: GestureDetector(
                  onLongPressStart: (d) {
                    // start mobile drag mode only on touch platforms
                    if (kIsWeb) return;
                    setState(() {
                      _mobileDragMode = true;
                      _mobileDragAnchorIndex = _indexFromLocalDy(d.localPosition.dy);
                      _mobileDragLastIndex = _mobileDragAnchorIndex;
                    });
                  },
                  onLongPressMoveUpdate: (d) {
                    if (!_mobileDragMode) return;
                    final idx = _indexFromLocalDy(d.localPosition.dy);
                    if (idx == _mobileDragLastIndex) return;

                    final anchor = _mobileDragAnchorIndex ?? idx;
                    final boundedIdx = idx.clamp(0, contacts.length - 1);
                    final boundedAnchor = anchor.clamp(0, contacts.length - 1);

                    // Mobile spec: selecting a range
                    _toggleRangeContacts(contacts, boundedAnchor, boundedIdx, true);

                    setState(() {
                      _mobileDragLastIndex = boundedIdx;
                    });
                  },
                  onLongPressEnd: (_) {
                    if (!_mobileDragMode) return;
                    setState(() {
                      _mobileDragMode = false;
                      _mobileDragAnchorIndex = null;
                      _mobileDragLastIndex = null;
                    });
                  },
                  child: ListView.builder(
                    itemExtent: _rowHeight,
                    itemCount: contacts.length,
                    itemBuilder: (context, i) {
                      final c = contacts[i];
                      final selected = _selectedMemberIds.contains(c.id);

                      return CompactContactTile(
                        contact: c,
                        selected: selected,
                        onAvatarTap: () => _showContactModal(c),
                        onToggle: () {
                          // Desktop/web: Shift selects range
                          final canShiftRange = (kIsWeb || defaultTargetPlatform == TargetPlatform.windows || defaultTargetPlatform == TargetPlatform.macOS || defaultTargetPlatform == TargetPlatform.linux) &&
                              _shiftDown;

                          if (canShiftRange && _lastTappedIndex != null) {
                            final select = !selected;
                            _toggleRangeContacts(contacts, _lastTappedIndex!, i, select);
                          } else {
                            _toggleSingleContact(c);
                          }

                          _lastTappedIndex = i;
                        },
                        // we keep long press hook but slide mode is handled by parent GestureDetector
                        onLongPressRow: () {
                          if (kIsWeb) return;
                          setState(() {
                            _mobileDragMode = true;
                            _mobileDragAnchorIndex = i;
                            _mobileDragLastIndex = i;
                          });
                        },
                      );
                    },
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: apps/mobile/lib/ui/screens/edit_contacts_screen.dart =====


import 'package:flutter/material.dart';
import '../../core/app_state.dart';
import '../../models/contact.dart';
import '../../services/api_client.dart';
import '../colors.dart';
import '../../services/contacts_api.dart';

class EditContactsScreen extends StatefulWidget {
  final AppState appState;
  const EditContactsScreen({super.key, required this.appState});

  @override
  State<EditContactsScreen> createState() => _EditContactsScreenState();
}

class _EditContactsScreenState extends State<EditContactsScreen> {
  bool _busy = false;
  String? _err;
  String _query = "";

  Future<void> _refresh() async {
    setState(() {
      _busy = true;
      _err = null;
    });

    try {
      await widget.appState.loadContacts();
    } catch (e) {
      _err = e.toString();
    } finally {
      if (mounted) setState(() => _busy = false);
    }
  }

  @override
  void initState() {
    super.initState();
    _refresh();
  }

  List<Contact> get _filtered {
    final q = _query.toLowerCase().trim();
    final list = widget.appState.contacts.toList()
      ..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));

    if (q.isEmpty) return list;

    return list.where((c) {
      return c.name.toLowerCase().contains(q) ||
          (c.organization ?? "").toLowerCase().contains(q) ||
          (c.phone ?? "").toLowerCase().contains(q) ||
          (c.email ?? "").toLowerCase().contains(q);
    }).toList();
  }

  Future<void> _delete(Contact c) async {
    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text("Delete contact?"),
        content: Text("This permanently deletes:\n\n${c.name}\n\nThis cannot be undone."),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text("Cancel")),
          FilledButton(onPressed: () => Navigator.pop(context, true), child: const Text("Delete")),
        ],
      ),
    );

    if (ok != true) return;

    setState(() {
      _busy = true;
      _err = null;
    });

    try {
      final client = ApiClient(baseUrl: widget.appState.baseUrl);
      final api = ContactsApi(client);

      await api.deleteContact(c.id);

      await widget.appState.loadContacts();
    } catch (e) {
      _err = e.toString();
    } finally {
      if (mounted) setState(() => _busy = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final items = _filtered;

    return Scaffold(
      appBar: AppBar(
        title: const Text("Edit Contacts"),
        backgroundColor: SFColors.primaryBlue,
        foregroundColor: Colors.white,
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            children: [
              TextField(
                decoration: InputDecoration(
                  hintText: "Search contacts",
                  prefixIcon: const Icon(Icons.search),
                  isDense: true,
                  filled: true,
                  fillColor: Colors.white,
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                ),
                onChanged: (v) => setState(() => _query = v),
              ),
              const SizedBox(height: 10),
              if (_err != null)
                Padding(
                  padding: const EdgeInsets.only(bottom: 10),
                  child: Text(_err!, style: const TextStyle(color: Colors.red)),
                ),
              Expanded(
                child: _busy
                    ? const Center(child: CircularProgressIndicator())
                    : ListView.builder(
                        itemCount: items.length,
                        itemBuilder: (context, i) {
                          final c = items[i];
                          return Container(
                            height: 60,
                            padding: const EdgeInsets.symmetric(horizontal: 10),
                            child: Row(
                              children: [
                                Expanded(
                                  child: Column(
                                    mainAxisAlignment: MainAxisAlignment.center,
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        c.name,
                                        style: const TextStyle(fontWeight: FontWeight.w800),
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                      const SizedBox(height: 2),
                                      Text(
                                        [
                                          if ((c.organization ?? "").trim().isNotEmpty) c.organization!.trim(),
                                          if ((c.phone ?? "").trim().isNotEmpty) "SMS",
                                          if ((c.email ?? "").trim().isNotEmpty) "Email",
                                        ].join(" â€¢ "),
                                        style: TextStyle(
                                          fontSize: 12,
                                          color: Colors.black.withOpacity(0.6),
                                          fontWeight: FontWeight.w600,
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                    ],
                                  ),
                                ),
                                IconButton(
                                  tooltip: "Delete",
                                  icon: const Icon(Icons.delete_outline),
                                  onPressed: () => _delete(c),
                                ),
                              ],
                            ),
                          );
                        },
                      ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: apps/mobile/lib/ui/components/compact_contact_tile.dart =====


import 'package:flutter/material.dart';
import '../../models/contact.dart';

class CompactContactTile extends StatelessWidget {
  final Contact contact;
  final bool selected;

  final VoidCallback onToggle;

  // Desktop shift-click handled by parent; mobile slide-range handled by parent.
  // We keep a long-press hook for starting mobile drag mode.
  final VoidCallback? onLongPressRow;

  final VoidCallback? onAvatarTap; // shows modal (compact)
  const CompactContactTile({
    super.key,
    required this.contact,
    required this.selected,
    required this.onToggle,
    this.onLongPressRow,
    this.onAvatarTap,
  });

  bool get hasSms => (contact.phone != null && contact.phone!.trim().isNotEmpty);
  bool get hasEmail => (contact.email != null && contact.email!.trim().isNotEmpty);

  String _initials(String name) {
    final parts = name.trim().split(RegExp(r"\s+")).where((p) => p.isNotEmpty).toList();
    if (parts.isEmpty) return "?";
    if (parts.length == 1) return parts.first.substring(0, 1).toUpperCase();
    return (parts[0].substring(0, 1) + parts[1].substring(0, 1)).toUpperCase();
  }

  @override
  Widget build(BuildContext context) {
    final org = (contact.organization ?? "").trim();

    // Shrink vertical spacing ~50% vs old tile: fixed height + tighter padding
    return InkWell(
      onTap: onToggle,
      onLongPress: onLongPressRow,
      child: Container(
        height: 56,
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        color: selected ? Colors.blue.withOpacity(0.08) : null,
        child: Row(
          children: [
            GestureDetector(
              onTap: onAvatarTap,
              child: Container(
                width: 36,
                height: 36,
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.06),
                  borderRadius: BorderRadius.circular(10),
                ),
                alignment: Alignment.center,
                child: Text(
                  _initials(contact.name),
                  style: const TextStyle(fontWeight: FontWeight.w800),
                ),
              ),
            ),
            const SizedBox(width: 10),

            // Name + org + chips
            Expanded(
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      contact.name,
                      style: const TextStyle(fontWeight: FontWeight.w800),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  if (org.isNotEmpty) ...[
                    const SizedBox(width: 10),
                    Expanded(
                      child: Text(
                        org,
                        textAlign: TextAlign.right, // âœ… org right aligned
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.blueGrey.withOpacity(0.9),
                          fontWeight: FontWeight.w600,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ],
              ),
            ),

            const SizedBox(width: 10),

            // chips left of checkbox
            if (hasSms)
              _chip("SMS"),
            if (hasEmail)
              _chip("Email"),

            const SizedBox(width: 8),

            // checkbox far right
            Checkbox(
              value: selected,
              onChanged: (_) => onToggle(),
              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
              visualDensity: const VisualDensity(horizontal: -3, vertical: -3),
            ),
          ],
        ),
      ),
    );
  }

  Widget _chip(String label) {
    return Padding(
      padding: const EdgeInsets.only(right: 6),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.06),
          borderRadius: BorderRadius.circular(999),
        ),
        child: Text(
          label,
          style: const TextStyle(fontSize: 11, fontWeight: FontWeight.w700),
        ),
      ),
    );
  }
}


===== FILE: apps/mobile/lib/services/api_client.dart =====


import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class ApiClient {
  final String baseUrl;

  static const _storage = FlutterSecureStorage();
  static const _tokenKey = 'auth_token';

  ApiClient({required this.baseUrl});

  Future<String?> getToken() async {
    return await _storage.read(key: _tokenKey);
  }

  Future<Map<String, String>> _headers() async {
    final token = await getToken();

    final h = <String, String>{
      'Content-Type': 'application/json',
    };

    if (token != null && token.isNotEmpty) {
      h['Authorization'] = 'Bearer $token';
    }

    return h;
  }

  Future<Map<String, dynamic>> getJson(String path) async {
    final uri = Uri.parse('$baseUrl$path');
    final res = await http.get(uri, headers: await _headers());

    final decoded = res.body.isEmpty ? {} : jsonDecode(res.body);

    if (res.statusCode >= 400) {
      throw ApiError(
        message: decoded is Map && decoded['error'] != null
            ? decoded['error'].toString()
            : res.body,
      );
    }

    return (decoded as Map<String, dynamic>);
  }

  Future<Map<String, dynamic>> postJson(String path, Map<String, dynamic> body) async {
    final uri = Uri.parse('$baseUrl$path');

    final res = await http.post(
      uri,
      headers: await _headers(),
      body: jsonEncode(body),
    );

    final decoded = res.body.isEmpty ? {} : jsonDecode(res.body);

    if (res.statusCode >= 400) {
      throw ApiError(
        message: decoded is Map && decoded['error'] != null
            ? decoded['error'].toString()
            : res.body,
      );
    }

    return (decoded as Map<String, dynamic>);
  }

  // âœ… match backend PUT routes
  Future<Map<String, dynamic>> putJson(String path, Map<String, dynamic> body) async {
    final uri = Uri.parse('$baseUrl$path');

    final res = await http.put(
      uri,
      headers: await _headers(),
      body: jsonEncode(body),
    );

    final decoded = res.body.isEmpty ? {} : jsonDecode(res.body);

    if (res.statusCode >= 400) {
      throw ApiError(
        message: decoded is Map && decoded['error'] != null
            ? decoded['error'].toString()
            : res.body,
      );
    }

    return (decoded as Map<String, dynamic>);
  }

  // âœ… required for HARD delete contacts
  Future<void> deleteJson(String path) async {
    final uri = Uri.parse('$baseUrl$path');

    final res = await http.delete(uri, headers: await _headers());

    final decoded = res.body.isEmpty ? {} : jsonDecode(res.body);

    if (res.statusCode >= 400) {
      throw ApiError(
        message: decoded is Map && decoded['error'] != null
            ? decoded['error'].toString()
            : res.body,
      );
    }
  }
}

class ApiError implements Exception {
  final String message;
  ApiError({required this.message});

  @override
  String toString() => message;
}


===== FILE: apps/mobile/lib/services/contacts_api.dart =====


import 'api_client.dart';

class ContactsApi {
  final ApiClient client;

  ContactsApi(this.client);

  Future<void> deleteContact(String contactId) async {
    await client.deleteJson('/v1/contacts/$contactId');
  }
}


===== FILE: apps/mobile/lib/ui/screens/groups_list_screen.dart =====


// comms-app/apps/mobile/lib/ui/screens/groups_list_screen.dart
import 'package:flutter/material.dart';
import '../../core/app_state.dart';
import '../../models/group.dart';
import '../../services/groups_api.dart';
import '../components/sf_card.dart';
import 'group_detail_screen.dart';

class GroupsListScreen extends StatefulWidget {
  final AppState appState;

  /// If true, this screen renders just the list (no scaffold),
  /// so GroupsScreen can embed it under the buttons.
  final bool embedMode;

  final Future<void> Function()? onRefresh;

  const GroupsListScreen({
    super.key,
    required this.appState,
    this.embedMode = false,
    this.onRefresh,
  });

  @override
  State<GroupsListScreen> createState() => _GroupsListScreenState();
}

class _GroupsListScreenState extends State<GroupsListScreen> {
  bool busy = true;
  List<Group> groups = [];
  String? error;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() {
      busy = true;
      error = null;
    });

    try {
      final api = GroupsApi(widget.appState);
      final data = await api.list();

      // keep AppState in sync
      widget.appState.groups
        ..clear()
        ..addAll(data);

      if (!mounted) return;
      setState(() {
        groups = data;
        busy = false;
      });
    } catch (e) {
      if (!mounted) return;
      setState(() {
        error = e.toString();
        busy = false;
      });
    }
  }

  Widget _content() {
    if (busy) return const Center(child: CircularProgressIndicator());
    if (error != null) return Center(child: Text(error!, style: const TextStyle(color: Colors.red)));
    if (groups.isEmpty) return const Center(child: Text("No groups yet."));

    return RefreshIndicator(
      onRefresh: () async {
        await _load();
        if (widget.onRefresh != null) await widget.onRefresh!();
      },
      child: ListView.separated(
        itemCount: groups.length,
        separatorBuilder: (_, __) => const SizedBox(height: 12),
        itemBuilder: (context, i) {
  final g = groups[i];
  final subtitle = g.type == "meta"
      ? '${g.memberCount} members (dynamic)'
      : '${g.memberCount} members';

  return InkWell(
    borderRadius: BorderRadius.circular(12),
    onTap: () async {
      await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => GroupDetailScreen(
            appState: widget.appState,
            group: g,
          ),
        ),
      );

      _load();
    },
    child: SFCard(
      title: g.name,
      subtitle: subtitle,
      child: const SizedBox.shrink(),
    ),
  );
},
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (widget.embedMode) return _content();

    return Scaffold(
      appBar: AppBar(title: const Text('Groups')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: _content(),
      ),
    );
  }
}


===== FILE: apps/mobile/lib/ui/screens/groups_screen.dart =====


import 'package:flutter/material.dart';
import '../../core/app_state.dart';
import '../colors.dart';
import 'create_group_screen.dart';
import 'groups_list_screen.dart';
import 'import_contacts_screen.dart';
import 'edit_contacts_screen.dart';

class GroupsScreen extends StatefulWidget {
  final AppState appState;

  const GroupsScreen({super.key, required this.appState});

  @override
  State<GroupsScreen> createState() => _GroupsScreenState();
}

class _GroupsScreenState extends State<GroupsScreen> {
  bool _loading = true;
  String? _err;

  @override
  void initState() {
    super.initState();
    _refresh();
  }

  Future<void> _refresh() async {
    setState(() {
      _loading = true;
      _err = null;
    });

    try {
      await widget.appState.loadContacts();
      await widget.appState.loadGroups();
    } catch (e) {
      _err = e.toString();
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: SFColors.background,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: _loading
              ? const Center(child: CircularProgressIndicator())
              : Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    _topButtonsRow(context),
                    const SizedBox(height: 14),
                    if (_err != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 10),
                        child: Text(
                          _err!,
                          style: const TextStyle(color: Colors.red),
                        ),
                      ),
                    Expanded(
                      child: GroupsListScreen(
                        appState: widget.appState,
                        embedMode: true,
                        onRefresh: _refresh,
                      ),
                    ),
                  ],
                ),
        ),
      ),
    );
  }

  // âœ… layout changed from vertical to horizontal
  // âœ… routing preserved
  Widget _topButtonsRow(BuildContext context) {
    final styleFilled = FilledButton.styleFrom(
      padding: const EdgeInsets.symmetric(vertical: 12),
    );
    final styleOutlined = OutlinedButton.styleFrom(
      padding: const EdgeInsets.symmetric(vertical: 12),
    );

    return Row(
      children: [
        Expanded(
          child: FilledButton(
            style: styleFilled,
            onPressed: () async {
              await Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (_) => CreateGroupScreen(
                    appState: widget.appState,
                    type: "snapshot",
                  ),
                ),
              );
              _refresh();
            },
            child: const Text(
              'Create Group',
              textAlign: TextAlign.center,
              style: TextStyle(fontWeight: FontWeight.w800, fontSize: 12),
            ),
          ),
        ),
        const SizedBox(width: 10),
        Expanded(
          child: FilledButton(
            style: styleFilled,
            onPressed: () async {
              await Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (_) => CreateGroupScreen(
                    appState: widget.appState,
                    type: "meta",
                  ),
                ),
              );
              _refresh();
            },
            child: const Text(
              'Create Meta',
              textAlign: TextAlign.center,
              style: TextStyle(fontWeight: FontWeight.w800, fontSize: 12),
            ),
          ),
        ),
        const SizedBox(width: 10),
        Expanded(
          child: OutlinedButton(
            style: styleOutlined,
            onPressed: () => Navigator.push(
              context,
              MaterialPageRoute(
                builder: (_) => ImportContactsScreen(appState: widget.appState),
              ),
            ),
            child: const Text(
              'Add Contacts',
              textAlign: TextAlign.center,
              style: TextStyle(fontWeight: FontWeight.w800, fontSize: 12),
            ),
          ),
        ),
        const SizedBox(width: 10),
        Expanded(
          child: OutlinedButton(
            style: styleOutlined,
            onPressed: () async {
              await Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (_) => EditContactsScreen(appState: widget.appState),
                ),
              );
              _refresh();
            },
            child: const Text(
              'Edit Contacts',
              textAlign: TextAlign.center,
              style: TextStyle(fontWeight: FontWeight.w800, fontSize: 12),
            ),
          ),
        ),
      ],
    );
  }
}


===== FILE: services/backend/src/routes/contacts.routes.js =====


import express from "express";
import { db } from "../config/db.js";
import { importContacts } from "../services/contactImport.service.js";

const router = express.Router();

/**
 * POST /v1/contacts/import
 * Auth required (req.user injected by upstream auth middleware)
 * Body:
 * {
 *   method: "google" | "csv" | "manual",
 *   contacts: [{ name, phone, email, organization?, sourceMeta? }]
 * }
 */
router.post("/import", async (req, res) => {
  try {
    const userId = req.user?.sub;
    if (!userId) {
      return res.status(401).json({ error: "missing_token" });
    }

    const { method, contacts } = req.body || {};

    if (!Array.isArray(contacts)) {
      throw new Error("contacts must be an array");
    }

    const result = await importContacts({
      userId,
      method,
      contacts,
    });

    return res.status(200).json({
      ok: true,
      ...result,
    });
  } catch (err) {
    return res.status(400).json({
      ok: false,
      error: err?.message || String(err),
    });
  }
});

/**
 * DELETE /v1/contacts/:id
 * HARD delete
 * - deletes group_members rows first (manual cascade)
 * - then deletes contact
 */
router.delete("/:id", async (req, res) => {
  try {
    const userId = req.user?.sub;
    if (!userId) {
      return res.status(401).json({ error: "missing_token" });
    }

    const contactId = String(req.params.id || "");

    if (!contactId) {
      return res.status(400).json({ ok: false, error: "missing_contact_id" });
    }

    // ensure the contact belongs to user (soft guard)
    const exists = await db("contacts")
      .select("id")
      .where({ id: contactId, user_id: userId })
      .first();

    if (!exists) {
      return res.status(404).json({ ok: false, error: "contact_not_found" });
    }

    // manual cascade (do NOT assume FK cascade exists)
    await db("group_members").where({ user_id: userId, contact_id: contactId }).del();

    await db("contacts").where({ user_id: userId, id: contactId }).del();

    return res.json({ ok: true });
  } catch (e) {
    return res.status(500).json({ ok: false, error: e?.message || String(e) });
  }
});

export default router;


===== FILE: services/backend/src/services/contactImport.service.js =====


// comms-app/services/backend/src/services/contactImport.service.js
import { parsePhoneNumberFromString } from "libphonenumber-js";

import { dedupeContacts } from "./dedupe.service.js";
import { auditLog } from "./audit.service.js";
import { db } from "../config/db.js";

/**
 * Normalize phone input to E.164 at ingestion.
 *
 * Goals:
 * - US numbers no longer flagged intl incorrectly (default region US when no +country code)
 * - Preserve existing import behavior (best-effort; invalids filtered)
 * - Do NOT touch tier logic
 *
 * Storage:
 * - contacts.phone_e164 receives normalized E.164
 * - we keep normalized object field "phone" as E.164 to remain compatible with dedupeContacts()
 */
function normalizePhoneToE164(raw) {
  if (typeof raw !== "string") return null;

  let s = raw.trim();
  if (!s) return null;

  // Remove common separators but keep leading +
  s = s.replace(/[()\-\.\s]/g, "");

  // Convert 00 prefix to +
  if (s.startsWith("00")) s = "+" + s.slice(2);

  // If it has letters, discard (avoid garbage)
  if (/[a-zA-Z]/.test(s)) return null;

  // If itâ€™s all digits, treat as national (US default)
  // Examples:
  //  - 10 digits -> US
  //  - 11 digits starting with 1 -> US
  //  - anything else -> attempt parse with US then fallback null
  const isDigitsOnly = /^[0-9]+$/.test(s);

  try {
    if (s.startsWith("+")) {
      const p = parsePhoneNumberFromString(s);
      if (p && p.isValid()) return p.number; // E.164
      return null;
    }

    if (isDigitsOnly) {
      if (s.length === 10) {
        const p = parsePhoneNumberFromString(s, "US");
        if (p && p.isValid()) return p.number;
        return null;
      }
      if (s.length === 11 && s.startsWith("1")) {
        const p = parsePhoneNumberFromString(s.slice(1), "US");
        if (p && p.isValid()) return p.number;
        return null;
      }

      // last-ditch: try parsing as US
      const p = parsePhoneNumberFromString(s, "US");
      if (p && p.isValid()) return p.number;
      return null;
    }

    // Non-digit national format: still try US (best-effort)
    const p = parsePhoneNumberFromString(s, "US");
    if (p && p.isValid()) return p.number;
    return null;
  } catch {
    return null;
  }
}

export async function importContacts({ userId, method, contacts }) {
  if (!userId) throw new Error("missing_user");

  const normalized = (contacts || []).map(normalize).filter(Boolean);

  const { unique, duplicates } = dedupeContacts(normalized);

  let inserted = 0;

  // Insert best-effort; count actual inserts (not just attempts)
  for (const c of unique) {
    const rows = await db("contacts")
      .insert({
        user_id: userId,
        name: c.name,
        // âœ… store E.164
        phone_e164: c.phone, // "phone" is E.164 in normalized object
        email: c.email,
        organization: c.organization || null,
        source: method,
        created_at: new Date(),
      })
      .onConflict(["user_id", "phone_e164", "email"])
      .ignore()
      .returning(["id"]);

    if (Array.isArray(rows) && rows.length > 0) inserted++;
  }

  // Audit should never block import success
  try {
    await auditLog(userId, "contacts_import", {
      method,
      inserted,
      duplicates: duplicates.length,
      invalid: (contacts?.length || 0) - normalized.length,
    });
  } catch (_) {
    // ignore
  }

  return {
    added: inserted,
    duplicates: duplicates.length,
    invalid: (contacts?.length || 0) - normalized.length,
    // keep these if you want them for debugging/UI (safe-ish)
    unique,
    duplicatesList: duplicates,
  };
}

function normalize(c) {
  if (!c) return null;

  const name = typeof c.name === "string" ? c.name.trim() : "";
  const organization = typeof c.organization === "string" ? c.organization.trim() : "";

  const rawPhone = typeof c.phone === "string" ? c.phone.trim() : "";
  const rawEmail = typeof c.email === "string" ? c.email.trim().toLowerCase() : "";

  const phoneE164 = rawPhone ? normalizePhoneToE164(rawPhone) : null;
  const email = rawEmail || null;

  // If both missing after normalization, skip
  if (!phoneE164 && !email) return null;

  return {
    name,
    organization: organization || null,
    // âœ… keep property name "phone" for dedupe compatibility, but value is E.164
    phone: phoneE164,
    email,
  };
}


===== FILE: services/backend/src/config/db.js =====


import knex from "knex";
import { env } from "./env.js";

export const db = knex({ client: "pg", connection: env.databaseUrl });


===== FILE: services/backend/knexfile.cjs =====


// knexfile.cjs
require("dotenv").config(); // <-- loads .env for knex CLI

module.exports = {
  client: "pg",
  connection: process.env.DATABASE_URL,
  migrations: { directory: "./src/db/migrations" },
};


===== FILE: services/backend/package.json =====


{
  "name": "comms-backend",
  "version": "1.0.0",
  "type": "module",
  "engines": {
    "node": ">=20 <21"
  },
  "scripts": {
    "start": "node src/server.js",
    "worker": "node src/jobs/worker.js",
    "migrate": "knex --knexfile knexfile.cjs migrate:latest"
  },
  "dependencies": {
    "@sendgrid/mail": "^8.1.4",
    "bcrypt": "^5.1.1",
    "bullmq": "^5.10.2",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "ioredis": "^5.4.1",
    "jsonwebtoken": "^9.0.2",
    "knex": "^3.1.0",
    "libphonenumber-js": "^1.12.34",
    "pg": "^8.12.0",
    "stripe": "^16.0.0",
    "tweetnacl": "^1.0.3",
    "tweetnacl-util": "^0.15.1",
    "twilio": "^5.0.0",
    "zod": "^3.23.8"
  }
}


===== FILE: services/backend/migrations/README.md =====


===== FILE NOT FOUND =====
